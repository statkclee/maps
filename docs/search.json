[
  {
    "objectID": "langchain.html",
    "href": "langchain.html",
    "title": "",
    "section": "",
    "text": "기본기랭체인 코드전체 코드 표시전체 코드 숨기기소스 코드 표시",
    "crumbs": [
      "기본기",
      "랭체인"
    ]
  },
  {
    "objectID": "langchain.html#허깅페이스",
    "href": "langchain.html#허깅페이스",
    "title": "",
    "section": "허깅페이스",
    "text": "허깅페이스\n파이썬과 R을 사용해 Hugging Face Hub의 대형 언어 모델(Large Language Model, LLM)을 활용한다. 파이썬에서는 필요한 라이브러리를 설치하고, R에서는 reticulate 라이브러리를 통해 파이썬 환경을 사용한다. 파이썬 코드에서 Hugging Face Hub에 접근하기 위한 API 토큰을 로드하고, HuggingFaceHub 클래스를 사용하여 특정 모델(‘tiiuae/falcon-7b-instruct’)에 질문을 하고, 모델의 답변을 출력한다.\n\npip install langchain_community, pip install dotenv, pip install huggingface_hub: 이 세 명령어는 파이썬 환경에서 필요한 패키지들을 설치한다. langchain_community는 언어 체인 커뮤니티 라이브러리, dotenv는 환경 변수를 관리하는 라이브러리, huggingface_hub는 Hugging Face Hub와 연동하는 데 사용되는 라이브러리다.\nR 코드 부분에서 library(reticulate)를 사용해 파이썬과 R 사이의 상호작용을 가능하게 하는 reticulate 라이브러리를 로드한다. use_condaenv(\"langchain\", required = TRUE)는 langchain이라는 이름의 Conda 환경을 사용하도록 지시한다. 이는 파이썬 코드를 R 환경에서 실행하기 위한 준비 단계다.\n파이썬 코드에서는 먼저 langchain_community.llms에서 HuggingFaceHub 클래스를, dotenv에서 load_dotenv 함수를 가져온다. 이후 os 모듈을 임포트한다. load_dotenv()를 호출하여 환경 변수를 로드한다. 이는 .env 파일에 저장된 환경 변수를 사용할 수 있게 한다.\nhuggingfacehub_api_token = os.getenv('HF_TOKEN')는 환경 변수에서 ’HF_TOKEN’을 찾아 해당 토큰을 변수에 저장한다. 이 토큰은 Hugging Face Hub에 접근할 때 인증을 위해 사용된다.\nHuggingFaceHub 클래스의 인스턴스를 생성한다. 이 때 repo_id에는 사용할 Hugging Face 모델의 저장소 ID를, huggingfacehub_api_token에는 위에서 얻은 API 토큰을 넣는다.\n대형 언어 모델에 질문을 하기 위해 question 변수에 질문을 저장하고, llm.invoke(question)을 호출하여 모델에 질문을 전달하고 결과를 받는다.\n마지막으로 print(output)을 통해 얻은 결과를 출력한다. 이 코드는 Hugging Face Hub의 특정 모델을 사용하여 질문에 대한 답변을 얻는 과정을 보여준다.\n\n\n\npip install langchain_community\npip install dotenv\npip install huggingface_hub\n\n\n코드library(reticulate)\n\nuse_condaenv(\"langchain\", required = TRUE)\n\n\n\n코드from langchain_community.llms import HuggingFaceHub\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nhuggingfacehub_api_token = os.getenv('HF_TOKEN')\n\nllm = HuggingFaceHub(repo_id='tiiuae/falcon-7b-instruct', \n                     huggingfacehub_api_token = huggingfacehub_api_token)\n\nquestion = 'what is an Large Language Model in artificial intelligence?'\noutput = llm.invoke(question)\n\nprint(output)",
    "crumbs": [
      "기본기",
      "랭체인"
    ]
  },
  {
    "objectID": "gh_action.html",
    "href": "gh_action.html",
    "title": "",
    "section": "",
    "text": "자동화깃헙 액션 코드전체 코드 표시전체 코드 숨기기소스 코드 표시",
    "crumbs": [
      "자동화",
      "깃헙 액션"
    ]
  },
  {
    "objectID": "gh_action.html#주식가격",
    "href": "gh_action.html#주식가격",
    "title": "",
    "section": "주식가격",
    "text": "주식가격\n네이버 금융 크롤링 파이썬 코드를 참고하여 챗GPT로 코드를 동작하는 코드를 생성한다.\n\n코드import requests\nfrom bs4 import BeautifulSoup\n\ndef get_stock_info(stock_code):\n    url = f\"https://finance.naver.com/item/main.nhn?code={stock_code}\"\n    response = requests.get(url)\n    soup = BeautifulSoup(response.text, 'html.parser')\n\n    # Attempt to extract the stock name with a more robust approach\n    company_info = soup.find(\"div\", {\"class\":\"h_company\"})\n    stock_name = company_info.find(\"a\").text\n\n    # Find the element containing the current price\n    current_price_container = soup.find(\"p\", {\"class\": \"no_today\"})\n    current_price = current_price_container.find(\"span\", {\"class\": \"blind\"}).get_text() if current_price_container else \"Price not found\"\n\n    return stock_name, current_price\n\n# Example usage\nstock_code = '005930'  # Samsung Electronics code\nstock_name, current_price = get_stock_info(stock_code)\nprint(f\"{stock_name} (code {stock_code}) 현재가격: {current_price} KRW.\")\n\n삼성전자 (code 005930) 현재가격: 74,900 KRW.\n\n\n\nR 코드로 변환\n프롬프트: 다음 코드를 R 코드로 변환해줘\n\n인코딩 이슈가 있어 read_html()에서 다음과 같이 변환한다.\n\n코드library(rvest)\n\nWarning: package 'rvest' was built under R version 4.3.3\n\n코드get_stock_info &lt;- function(stock_code) {\n  url &lt;- sprintf(\"https://finance.naver.com/item/main.nhn?code=%s\", stock_code)\n  webpage &lt;- read_html(url,  encoding = \"euc-kr\")  # Setting the encoding to EUC-KR\n  \n  # Attempt to extract the stock name with a more robust approach\n  company_info &lt;- html_node(webpage, \"div.h_company\")\n  stock_name &lt;- html_text(html_node(company_info, \"a\"))\n\n  # Find the element containing the current price\n  current_price_container &lt;- html_node(webpage, \"p.no_today\")\n  if (!is.null(current_price_container)) {\n    current_price &lt;- html_text(html_node(current_price_container, \"span.blind\"))\n  } else {\n    current_price &lt;- \"Price not found\"\n  }\n  \n  list(stock_name = stock_name, current_price = current_price)\n}\n\n# Example usage\nstock_code &lt;- '005930'  # Samsung Electronics code\ninfo &lt;- get_stock_info(stock_code)\ncat(sprintf(\"%s (code %s) 현재가격: %s KRW.\\n\", info$stock_name, stock_code, info$current_price))\n\n삼성전자 (code 005930) 현재가격: 74,900 KRW.",
    "crumbs": [
      "자동화",
      "깃헙 액션"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "코드\n\n\n\n\n\n선거지형",
    "crumbs": [
      "선거지형"
    ]
  },
  {
    "objectID": "target.html",
    "href": "target.html",
    "title": "",
    "section": "",
    "text": "타겟(target)타겟 코드",
    "crumbs": [
      "타겟(target)",
      "타겟"
    ]
  },
  {
    "objectID": "target.html#footnotes",
    "href": "target.html#footnotes",
    "title": "",
    "section": "각주",
    "text": "각주\n\n\n런타임(runtime)은 프로그램이 실제로 실행되는 시간을 의미한다. 코드를 작성하고 컴파일하는 시간은 런타임에 포함되지 않고, 프로그램이 실행을 시작하는 순간부터 종료되는 순간까지의 시간이 런타임이다. 즉, 런타임 동안에는 프로그램이 메모리를 할당받고, 변수들이 값을 가지게 되며, 함수가 호출되고 실행된다.↩︎",
    "crumbs": [
      "타겟(target)",
      "타겟"
    ]
  },
  {
    "objectID": "target.html#동영상",
    "href": "target.html#동영상",
    "title": "",
    "section": "동영상",
    "text": "동영상",
    "crumbs": [
      "타겟(target)",
      "타겟"
    ]
  },
  {
    "objectID": "target.html#정의",
    "href": "target.html#정의",
    "title": "",
    "section": "정의",
    "text": "정의\ntargets는 Will Landau가 개발하고 유지 관리하는 R 프로그래밍 언어용 작업흐름(Workflow) 관리 패키지다.\ntargets의 주요 기능은 다음과 같다.\n\n작업흐름 자동화\n작업흐름 단계 캐싱\n작업흐름 단계 일괄 생성\n작업흐름 수준에서 병렬화\n\n이를 통해 다음과 같은 작업을 할 수 있다.\n\n다른 일을 하다가 프로젝트로 돌아왔을 때, 혼란 없이 그리고 무엇을 하고 있었는지 기억하려 노력하지 않고도 바로 중단했던 부분부터 다시 시작할 수 있다.\n작업흐름를 변경한 다음, 변경의 영향을 받는 부분만 다시 실행한다.\n\n개별 함수를 변경하지 않고도 작업흐름를 대규모로 확장한다.\n\n… 그리고 물론, 이는 다른 사람들이 여러분의 분석을 재현하는 데 도움을 줄 것이다.",
    "crumbs": [
      "타겟(target)",
      "타겟"
    ]
  },
  {
    "objectID": "target.html#누가-targets를-사용해야-하는가",
    "href": "target.html#누가-targets를-사용해야-하는가",
    "title": "",
    "section": "누가 targets를 사용해야 하는가?",
    "text": "누가 targets를 사용해야 하는가?\ntargets는 결코 유일한 작업흐름 관리 소프트웨어가 아니다. 다양한 기능과 사용 사례를 가진 유사한 도구들이 많이 있다. 예를 들어, snakemake는 파이썬에서 인기 있는 작업흐름 도구이고, make는 bash 스크립트를 자동화하기 위해 오랫동안 사용되어 온 도구이다. targets는 특별히 R과 함께 작동하도록 설계되었기 때문에, 주로 R을 사용하거나 사용하려는 경우에 가장 적합하다. 대부분 다른 도구로 코딩한다면, 다른 대안을 고려해 보는 것이 좋다.\n\n재현 가능성이란 무엇인가?\n재현 가능성은 다른 사람들(미래의 자신 포함)이 여러분의 분석을 재현할 수 있는 능력이다. 과학적 분석 결과에 대해 확신을 가질 수 있는 유일한 방법은 그 결과를 재현할 수 있을 때뿐이다. 그러나 재현 가능성은 이분법적 개념(재현 불가능 vs. 재현 가능)이 아니다. 오히려 덜 재현 가능한 것에서 더 재현 가능한 것까지 스펙트럼이 존재한다.\ntargets는 여러분의 분석을 더 재현 가능하게 만드는 데 큰 도움을 준다.\nDocker, conda, renv와 같은 도구로 컴퓨팅 환경을 제어하는 것도 재현 가능성을 더욱 높이는 데 사용할 수 있다.",
    "crumbs": [
      "타겟(target)",
      "타겟"
    ]
  },
  {
    "objectID": "gcs.html",
    "href": "gcs.html",
    "title": "",
    "section": "",
    "text": "GCP버킷 코드",
    "crumbs": [
      "GCP",
      "버킷"
    ]
  },
  {
    "objectID": "gcs.html#버킷-생성",
    "href": "gcs.html#버킷-생성",
    "title": "",
    "section": "버킷 생성",
    "text": "버킷 생성\n\nGCS\n\nCloud Console 열기: Google Cloud Console로 이동합니다.\n프로젝트 선택: 버킷을 만들 프로젝트를 선택합니다.\nCloud Storage로 이동: 네비게이션 메뉴에서 “Cloud Storage” &gt; “Browser”를 선택합니다.\n버킷 생성:\n\n“Create bucket” 버튼을 클릭합니다.\n버킷 이름을 입력합니다. 버킷 이름은 전 세계에서 유일해야 합니다.\n버킷 위치를 선택합니다. 필요에 따라 특정 지역, 다중 지역 또는 이중 지역을 선택할 수 있습니다.\n기본 스토리지 클래스를 선택합니다. 이는 저장된 데이터의 비용 및 가용성에 영향을 미칩니다.\n접근 제어를 설정합니다. “Uniform” 또는 “Fine-grained” 접근 제어를 선택할 수 있습니다.\n필요한 추가 설정을 구성합니다.\n“Create”를 클릭하여 버킷을 만듭니다.\n\n\n\n\ngsutil 도구\nGoogle Cloud SDK에 포함된 gsutil은 Cloud Storage와 상호작용할 수 있는 명령어 도구다.\n\nGoogle Cloud SDK 설치:\n\nGoogle Cloud SDK 설치 페이지의 지침에 따라 Google Cloud SDK를 설치합니다.\n\nSDK 초기화:\ngcloud init\nGCS 버킷 만들기:\ngsutil mb -p [PROJECT_ID] -l [LOCATION] gs://[BUCKET_NAME]/\n\n[PROJECT_ID]를 Google Cloud 프로젝트 ID로 바꿉니다.\n[LOCATION]을 버킷 위치로 바꿉니다 (예: us-central1, us, EU).\n[BUCKET_NAME]을 고유한 버킷 이름으로 바꿉니다.\n\n예제: sh  gsutil mb -p alookso-id -l asia-northeast3 gs://my-buckets-name/  gstutil ls\n\n\n\n파이썬과 GC 클라이언트\nPython을 사용하여 Google Cloud 클라이언트 라이브러리를 통해 프로그래밍 방식으로 GCS 버킷을 만들 수도 있습니다.\n\nGoogle Cloud Storage 클라이언트 라이브러리 설치:\npip install google-cloud-storage\nPython을 사용하여 버킷 생성:\nfrom google.cloud import storage\n\n# GCS 클라이언트 초기화\nclient = storage.Client()\n\n# 버킷 이름과 위치 정의\nbucket_name = 'your-unique-bucket-name'\nlocation = 'US'  # 또는 'us-central1'과 같은 지역 지정\n\n# 버킷 생성\nbucket = client.bucket(bucket_name)\nnew_bucket = client.create_bucket(bucket, location=location)\n\nprint(f'Bucket {new_bucket.name} created.')\n\n\n\n예제\n아래는 Python을 사용하여 GCS 버킷을 생성하는 전체 예제입니다:\nimport os\nfrom google.cloud import storage\n\n# 인증 설정\nos.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'path/to/your-service-account-file.json'\n\n# GCS 클라이언트 초기화\nclient = storage.Client()\n\n# 버킷 이름과 위치 정의\nbucket_name = 'your-unique-bucket-name'\nlocation = 'US'  # 또는 'us-central1'과 같은 지역 지정\n\n# 버킷 생성\nbucket = client.bucket(bucket_name)\nnew_bucket = client.create_bucket(bucket, location=location)\n\nprint(f'Bucket {new_bucket.name} created.')",
    "crumbs": [
      "GCP",
      "버킷"
    ]
  },
  {
    "objectID": "gcs.html#버킷-권한",
    "href": "gcs.html#버킷-권한",
    "title": "",
    "section": "버킷 권한",
    "text": "버킷 권한\n서비스 계정에 적절한 권한을 부여해야 합니다. 다음 단계를 따라 권한을 부여할 수 있습니다:\n\nGoogle Cloud Console에 접속합니다.\n프로젝트를 선택합니다.\n왼쪽 메뉴에서 “Storage” 메뉴를 선택합니다.\n버킷명 버킷을 찾아 클릭합니다.\n상단 메뉴에서 “권한” 탭을 클릭합니다.\n“구성원 추가” 버튼을 클릭합니다.\n“새 구성원” 입력란에 youtube-analytics-api@버킷명.iam.gserviceaccount.com 서비스 계정 이메일을 입력합니다.\n역할 선택란에서 “Storage 객체 관리자” 또는 “Storage 객체 생성자” 역할을 선택합니다. 이 역할은 버킷 내의 객체에 대한 읽기/쓰기 권한을 부여합니다.\n“저장” 버튼을 클릭하여 권한을 저장합니다.",
    "crumbs": [
      "GCP",
      "버킷"
    ]
  },
  {
    "objectID": "chat.html",
    "href": "chat.html",
    "title": "",
    "section": "",
    "text": "코드\n\n\n\n\n\n인구통계"
  },
  {
    "objectID": "demographics.html",
    "href": "demographics.html",
    "title": "",
    "section": "",
    "text": "인구통계인구통계 코드인구통계\n\n데이터 출처: KOSIS API\n\n\n\n\n\n\n\n지도\n2023년 기준 시군구별 인구수를 지도에 표시합니다.",
    "crumbs": [
      "인구통계",
      "인구통계"
    ]
  },
  {
    "objectID": "parliamentary.html",
    "href": "parliamentary.html",
    "title": "",
    "section": "",
    "text": "총선총선 코드\n\n\n\n\n\n총선",
    "crumbs": [
      "총선",
      "총선"
    ]
  },
  {
    "objectID": "office.html",
    "href": "office.html",
    "title": "",
    "section": "",
    "text": "총선예비후보 선거사무소 코드예비후보 선거사무소\n\n제22대 총선 중앙선거관리위원회 예비후보 선거사무소 위치 데이터를 활용하여 지도에 시각화합니다.",
    "crumbs": [
      "총선",
      "예비후보 선거사무소"
    ]
  }
]